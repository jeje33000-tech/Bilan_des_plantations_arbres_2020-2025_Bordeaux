<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<title>Swipe Avant/Après - Stats visible sur "Après"</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
<link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-compare/v0.4.0/mapbox-gl-compare.css" rel="stylesheet" />
<style>
  html,body { margin:0; height:100%; }
  #container { position:relative; width:100%; height:100vh; }
  #before,#after { position:absolute; top:0; bottom:0; width:100%; }
  .legend {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255,255,255,0.95);
    padding: 6px 8px;
    border-radius:6px;
    font-family: Arial, sans-serif;
    font-size:12px;
    z-index:1000;
  }
  .legend h4 { margin:4px 0; font-size:13px; }
  .legend div { display:flex; align-items:center; gap:6px; margin:2px 0; }
  .color-box { width:14px; height:12px; border:1px solid #444; flex-shrink:0; }
  #label-left,#label-right {
    position:absolute;
    bottom:26px;
    padding:6px 10px;
    font-weight:bold;
    background: rgba(255,255,255,0.9);
    border-radius:4px;
    font-family: Arial, sans-serif;
    z-index:1000;
    pointer-events:none;
    transition:opacity .2s;
    font-size:13px;
  }
  #label-left { left:10px; }
  #label-right { right:10px; }
  #label-right::after { content: " ➔"; }
  #stats {
    position:absolute;
    bottom:10px;
    right:10px;
    width:260px;
    height:170px;
    background: rgba(255,255,255,0.95);
    border-radius:6px;
    padding:8px;
    font-family: Arial, sans-serif;
    z-index:1000;
  }
  /* small responsive */
  @media (max-width:480px){
    .legend{font-size:11px}
    #stats{width:200px;height:140px}
  }
</style>
</head>
<body>

<div id="container">
  <div id="after"></div>  <!-- carte après (gauche sous swipe) -->
  <div id="before"></div> <!-- carte avant (droite) -->
</div>

<div id="label-left">Après 2020</div>
<div id="label-right">Avant 2020</div>

<div id="legend" class="legend"></div>
<div id="stats"><canvas id="chart"></canvas></div>

<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-compare/v0.4.0/mapbox-gl-compare.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
/* === CONFIG === */
mapboxgl.accessToken = 'pk.eyJ1IjoiamVqZTMzMDAwIiwiYSI6ImNtZTJ2c3RnaDAwczEyanF6bW9wODI0cTgifQ.AYOAKWDyDLP_fbKIz-QdwQ';
const centerBordeaux = [-0.57409, 44.861022];

/* === INITIALISATION CARTES === */
const afterMap = new mapboxgl.Map({
  container: 'after',
  style: 'mapbox://styles/mapbox/dark-v11',
  center: centerBordeaux,
  zoom: 11.5
});
const beforeMap = new mapboxgl.Map({
  container: 'before',
  style: 'mapbox://styles/mapbox/dark-v11',
  center: centerBordeaux,
  zoom: 11.5
});

// navigation controls
afterMap.addControl(new mapboxgl.NavigationControl({ showCompass:true, showZoom:true }), 'top-right');
beforeMap.addControl(new mapboxgl.NavigationControl({ showCompass:true, showZoom:true }), 'top-right');

// compare (after à gauche, before à droite)
const compare = new mapboxgl.Compare(afterMap, beforeMap, document.getElementById('container'), {});

// helper to read slider position robustly
function getSliderPos() {
  if (typeof compare.getSliderPosition === 'function') return compare.getSliderPosition();
  if (compare._slider && typeof compare._slider._pos === 'number') return compare._slider._pos;
  // fallback middle
  return 0.5;
}

/* === LAYERS CONFIG (fichiers geojson dans le même dossier) === */
const layersAvant = [
  { map: beforeMap, id: 'avant-layer', source: 'avant', file: 'avant.geojson', color: '#2E8B57', label: 'Stations avant 2020', data: null, totalCount:0 }
];
const layersApres = [
  { map: afterMap, id: 'apres1-layer', source:'apres1', file:'apres1.geojson', color:'#FF4500', label:'Stations créées ou en cours', data:null, totalCount:0 },
  { map: afterMap, id: 'apres2-layer', source:'apres2', file:'apres2.geojson', color:'orange', label:'Stations remplacées/densifiées', data:null, totalCount:0 },
  { map: afterMap, id: 'apres3-layer', source:'apres3', file:'apres3.geojson', color:'green', label:'Stations non plantées', data:null, totalCount:0 }
];

let popup = null;

/* util: centroid approximatif (moyenne des sommets du premier anneau) */
function featureCentroid(feature){
  if(!feature || !feature.geometry) return null;
  const g = feature.geometry;
  if (g.type === 'Point') return g.coordinates;
  if (g.type === 'Polygon' && Array.isArray(g.coordinates[0]) ) {
    const ring = g.coordinates[0];
    let sx=0, sy=0, n=0;
    ring.forEach(pt => { sx += pt[0]; sy += pt[1]; n++; });
    return n? [sx/n, sy/n] : null;
  }
  if (g.type === 'MultiPolygon' && Array.isArray(g.coordinates[0]) && Array.isArray(g.coordinates[0][0])) {
    const ring = g.coordinates[0][0];
    let sx=0, sy=0, n=0;
    ring.forEach(pt => { sx += pt[0]; sy += pt[1]; n++; });
    return n? [sx/n, sy/n] : null;
  }
  return null;
}

/* addLayer -> ajoute couche, label et source de highlight séparée pour mise à jour facile */
async function addLayer(info) {
  try {
    const res = await fetch(info.file);
    if(!res.ok) throw new Error('Erreur chargement ' + info.file);
    const geojson = await res.json();
    info.data = geojson;
    info.totalCount = geojson.features ? geojson.features.length : 0;

    // source
    if (!info.map.getSource(info.source)) {
      info.map.addSource(info.source, { type:'geojson', data: geojson });
    } else {
      info.map.getSource(info.source).setData(geojson);
    }

    // fill
    if (!info.map.getLayer(info.id)) {
      info.map.addLayer({
        id: info.id,
        type: 'fill',
        source: info.source,
        paint: {
          'fill-color': info.color,
          'fill-opacity': 0.6
        }
      });
    }

    // highlight source + layer (seul pour afterMap)
    const highlightSourceId = info.id + '-highlight-src';
    const highlightLayerId = info.id + '-highlight';
    if (info.map === afterMap) {
      if (!info.map.getSource(highlightSourceId)) {
        info.map.addSource(highlightSourceId, { type:'geojson', data: { type:'FeatureCollection', features: [] } });
        info.map.addLayer({
          id: highlightLayerId,
          type: 'fill',
          source: highlightSourceId,
          paint: {
            'fill-color': '#ffff00',
            'fill-opacity': 0.30
          }
        });
      }
    }

    // label layer
    const labelLayerId = info.id + '-label';
    if (!info.map.getLayer(labelLayerId)) {
      info.map.addLayer({
        id: labelLayerId,
        type: 'symbol',
        source: info.source,
        layout: {
          'text-field': ['coalesce', ['get', 'CODE_STATION'], ''],
          'text-font': ['Open Sans Bold','Arial Unicode MS Bold'],
          'text-size': 11,
          'text-anchor': 'center',
          'visibility': (info.map.getZoom() >= 15 ? 'visible' : 'none')
        },
        paint: {
          'text-color': info.color,
          'text-halo-color': '#000',
          'text-halo-width': 1
        }
      });
    }

    // events : labels visibility on zoom
    info.map.on('zoomend', () => {
      const visibility = info.map.getZoom() >= 15 ? 'visible' : 'none';
      if (info.map.getLayer(labelLayerId) && info.map.getLayoutProperty(labelLayerId, 'visibility') !== visibility) {
        info.map.setLayoutProperty(labelLayerId, 'visibility', visibility);
      }
      updateStats();
    });

    // moves -> update stats (we update only afterMap view)
    if (info.map === afterMap) {
      info.map.on('moveend', updateStats);
    }

    // feature click -> popup + set highlight source data
    info.map.on('click', info.id, (e) => {
      if (!e || !e.features || !e.features.length) return;
      const feature = e.features[0];
      const coords = e.lngLat;
      const code = (feature.properties && feature.properties.CODE_STATION) ? feature.properties.CODE_STATION : 'N/A';

      // popup
      if (popup) popup.remove();
      popup = new mapboxgl.Popup({ offset: 6 })
        .setLngLat(coords)
        .setHTML(`<strong>CODE_STATION</strong>: ${code}`)
        .addTo(info.map);

      // highlight: set highlight source data = this feature
      if (info.map === afterMap) {
        const highlightSource = info.map.getSource(info.id + '-highlight-src');
        if (highlightSource) {
          highlightSource.setData({ type:'FeatureCollection', features: [feature] });
        }
      }
    });

    // click anywhere on afterMap outside features -> clear highlight and popup
    if (info.map === afterMap) {
      info.map.on('click', (e) => {
        const hits = afterMap.queryRenderedFeatures(e.point, { layers: layersApres.map(l=>l.id) });
        if (!hits.length) {
          // clear highlight sources
          layersApres.forEach(l => {
            const src = afterMap.getSource(l.id + '-highlight-src');
            if (src) src.setData({ type:'FeatureCollection', features: [] });
          });
          if (popup) { popup.remove(); popup = null; }
        }
      });
    }

    // cursor pointer
    info.map.on('mouseenter', info.id, () => { info.map.getCanvas().style.cursor = 'pointer'; });
    info.map.on('mouseleave', info.id, () => { info.map.getCanvas().style.cursor = ''; });

  } catch (err) {
    console.error(err);
  }
}

/* charge toutes les couches */
async function loadAll() {
  const all = [...layersAvant, ...layersApres];
  for (const l of all) await addLayer(l);
  createLegend();
  initChart();
  updateStats();
}
loadAll();

/* calcule bounds géographiques de la portion visible LEFT (afterMap) */
function getVisibleBoundsAfter() {
  const container = document.getElementById('container');
  const containerRect = container.getBoundingClientRect();
  const containerWidth = containerRect.width;

  // position du slider (0..1)
  const sliderPos = getSliderPos();

  // visible width in container pixels for afterMap
  const visibleWidth = Math.max(0, Math.min(containerWidth, sliderPos * containerWidth));

  // canvas rect of afterMap
  const canvasRect = afterMap.getCanvas().getBoundingClientRect();
  const offsetX = canvasRect.left - containerRect.left; // offset of canvas relative to container

  // compute pixel coords relative to canvas
  const leftPx = 0 - offsetX;
  const rightPx = visibleWidth - offsetX;

  // clamp to canvas bounds
  const clampedLeft = Math.max(0, Math.min(canvasRect.width, leftPx));
  const clampedRight = Math.max(0, Math.min(canvasRect.width, rightPx));

  // if no visible width within canvas -> return empty bounds (so count = 0)
  if (clampedRight <= 0) {
    // return bounds that contains nothing by using a tiny degenerate area
    const p = afterMap.getCenter();
    return new mapboxgl.LngLatBounds([p.lng+0.0000001,p.lat+0.0000001],[p.lng+0.0000002,p.lat+0.0000002]);
  }

  // unproject top-left and bottom-right in canvas pixel coordinates
  const topLeft = afterMap.unproject([clampedLeft, 0]);
  const bottomRight = afterMap.unproject([clampedRight, canvasRect.height]);

  return new mapboxgl.LngLatBounds(topLeft, bottomRight);
}

/* compte features des layersApres dans les bounds visible after */
function countVisibleAfterForLayer(layerInfo) {
  if(!layerInfo.data || !layerInfo.data.features) return 0;
  const bounds = getVisibleBoundsAfter();
  let n = 0;
  for (const f of layerInfo.data.features) {
    const coord = featureCentroid(f);
    if (!coord) continue;
    if (bounds.contains(coord)) n++;
  }
  return n;
}

/* ===== LEGEND ===== */
function createLegend(){
  const el = document.getElementById('legend');
  el.innerHTML = '';
  const h1 = document.createElement('h4'); h1.textContent = 'Avant 2020'; el.appendChild(h1);
  layersAvant.forEach(l => {
    if (!l.data) return;
    const row = document.createElement('div');
    const c = document.createElement('span'); c.className='color-box'; c.style.background = l.color;
    row.appendChild(c);
    row.appendChild(document.createTextNode(l.label + ' (total)'));
    const s = document.createElement('span'); s.className='count'; s.textContent = l.totalCount;
    row.appendChild(s);
    el.appendChild(row);
  });
  const h2 = document.createElement('h4'); h2.textContent = 'Après 2020'; el.appendChild(h2);
  layersApres.forEach(l => {
    if (!l.data) return;
    const row = document.createElement('div');
    const c = document.createElement('span'); c.className='color-box'; c.style.background = l.color;
    row.appendChild(c);
    row.appendChild(document.createTextNode(l.label + ' (total)'));
    const s = document.createElement('span'); s.className='count'; s.textContent = l.totalCount;
    row.appendChild(s);
    el.appendChild(row);
  });
}

/* ===== CHART ===== */
let chartInstance = null;
function initChart(){
  const ctx = document.getElementById('chart').getContext('2d');
  chartInstance = new Chart(ctx, {
    type:'bar',
    data:{ labels: layersApres.map(l=>l.label), datasets:[{ label:'Stations visibles (Après)', data: layersApres.map(()=>0), backgroundColor: layersApres.map(l=>l.color) }] },
    options:{
      responsive:true, maintainAspectRatio:false,
      scales:{ y:{ beginAtZero:true, ticks:{ stepSize:1 } } },
      plugins:{ legend:{ display:false } }
    }
  });
}

/* ===== UPDATE STATS (uniquement layersApres et uniquement portion après) ===== */
function updateStats(){
  // recalcul visible counts
  layersApres.forEach(l => {
    l.visibleCount = countVisibleAfterForLayer(l);
  });

  // update chart data
  if(chartInstance){
    chartInstance.data.labels = layersApres.map(l=>l.label);
    chartInstance.data.datasets[0].data = layersApres.map(l=>l.visibleCount);
    chartInstance.data.datasets[0].backgroundColor = layersApres.map(l=>l.color);
    chartInstance.update();
  }

  // debug
  // console.log('visible counts', layersApres.map(l=>({label:l.label, visible:l.visibleCount})));
}

/* update labels opacity when slider moves */
compare.on('slide', (e) => {
  const pos = (typeof e.detail === 'number') ? e.detail : getSliderPos();
  document.getElementById('label-left').style.opacity = pos;
  document.getElementById('label-right').style.opacity = 1 - pos;
  updateStats();
});

/* also refresh stats on afterMap moveend/zoomend so panning/zoom triggers recalc */
afterMap.on('moveend', updateStats);
afterMap.on('zoomend', updateStats);

/* finally, refresh stats on window resize (slider layout changes) */
window.addEventListener('resize', () => { setTimeout(()=>{ updateStats(); }, 120); });

</script>
</body>
</html>


